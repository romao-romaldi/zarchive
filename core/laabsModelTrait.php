<?php
/**
 * Trait for model management
 */
trait laabsModelTrait
{
    /* Properties */
    private static $phpTypes = array(
        'float',
        'boolean',
        'string',
        'integer',
        'resource',
        'null',
        'array',
        'object',
        );

    private static $derivedTypes = array(
        'double' => 'float',    // Php base type declared to laabs base type
        'real' => 'float',      // Php base type declared to laabs base type
        'decimal' => 'float',
        'number' => 'float',
            //'integer' => 'integer',
                //'nonPositiveInteger' => 'integer',
                //    'negativeInteger' => 'integer',
                //'long' => 'integer',
                    'int' => 'integer', // Php base type declared to laabs base type
                        //'short' => 'integer',
                        //    'byte' => 'integer',
                //'nonNegativeInteger' => 'integer',
                //    'positiveInteger' => 'integer',
                //    'unsignedLong' => 'integer',
                //        'unsignedInt' => 'integer',
                //            'unsignedShort' => 'integer',
                //                'unsignedByte' => 'integer',

        //'boolean' => 'boolean',
        'bool' => 'boolean', // Php base type declared to laabs base type

        //'string' => 'string',
            //'normalizedString' => 'string',
                //'token' => 'string',
                    //'language' => 'string',
                    'name' => 'string', // String that starts with [a-zA-z_] and contains only [a-zA-Z0-9_]
                        //'NCName' => 'string',
                            //'ID' => 'string',
                            //'IDREF' => 'string',
                            //'ENTITY' => 'string',
                    //'NMTOKEN' => 'string',
        'qname' => 'string', // Names separated by Uri separator (qualified class name)
        //'NOTATION' => 'string',

        'date' => 'string',
        //'time' => 'string',
        'timestamp' => 'string',
        //'year' => 'string',
        //'yearmonth' => 'string',
        //'month' => 'string',
        //'monthday' => 'string',
        //'day' => 'string',
        'duration' => 'string',

        'base64binary' => 'string',
        //'resource' => 'resource',
        'binary' => 'string',

        //'anyURI' => 'string',

        'id' => 'string', // String that starts with [a-zA-Z0-9\-_] and contains only [a-zA-Z0-9\-\/_]
        'xml' => 'object', // Xml DOM Object
        'tokenlist' => 'string',
        'json' => 'string',
        'xstring' => 'string',
    );

    private static $scalarTypes = array(
            'int',
            'integer',

            'float',
            'double',
            'real',
            'number',

            'string',
            'name',
            'qname',
            'id',

            'date',
            'time',
            'timestamp',
            'duration',

            'bool',
            'boolean',

            'xml',

            'binary',
        );

    private static $typePatterns = array(
            'int' => '[0-9]+',
            'integer' => '[0-9]+',

            'string' => '[A-Za-z0-9_\-]*',
            'name' => '[A-Za-z0-9_\-]*',
            'qname' => '[A-Za-z_][A-Za-z0-9_]*/[A-Za-z_][A-Za-z0-9_]*',

            'bool' => '(true|false|0|1)',
            'boolean' => '(true|false|0|1)',
        );

    /**
     * Array of validation errors gathered during the last call to laabs::validate
     *
     * @var array
     */
    private static $validationErrors;

    /**
     * The result of the last call to laabs::validate
     *
     * @var bool
     */
    private static $validationStatus;

    /**
     * The last object id generated by calling laabs::objectId
     *
     * @var string
     */
    private static $objectId;

    /* Methods */

    /**
     * Get a new Id object
     * @param string $id
     * @param string $prefix
     *
     * @return Id
     */
    public static function newId($id = null, $prefix = null)
    {
        return new \core\Type\Id($id, $prefix);
    }

    /**
     * Get a new name object
     * @param string $name
     *
     * @return Name
     */
    public static function newName($name)
    {
        return new \core\Type\Name($name);
    }

    /**
     * Get a new qname object
     * @param string $qname
     *
     * @return QName
     */
    public static function newQName($qname)
    {
        return new \core\Type\QName($qname);
    }

    /**
     * Get a new Date object
     * @param string $date
     * @param string $format
     *
     * @return Date
     */
    public static function newDate($date = null, $format = null)
    {
        return new \core\Type\Date($date, $format);
    }

    /**
     * Get a new Datetime object
     * @param string $date
     * @param string $timezone
     *
     * @return DateTime
     */
    public static function newDateTime($date = null, $timezone = null)
    {
        return new \core\Type\DateTime($date, $timezone);
    }

    /**
     * Get a new Timestamp object
     * @param string $timestamp
     *
     * @return Timestamp
     */
    public static function newTimestamp($timestamp = null)
    {
        return new \core\Type\Timestamp($timestamp);
    }

    /**
     * Get a new Duration object
     * @param string $duration
     *
     * @return Duration
     */
    public static function newDuration($duration = null)
    {
        return new \core\Type\Duration($duration);
    }

    /**
     * Get a new Number object
     * @param mixed $number
     *
     * @return Number
     */
    public static function newNumber($number = null)
    {
        return new \core\Type\Number((float) $number);
    }

    /**
     * Get a new Xml object
     * @param string $xml
     * @param string $encoding
     *
     * @return Xml
     */
    public static function newXml($xml = null, $encoding = null)
    {
        return new \core\Type\Xml($xml, $encoding);
    }

    /**
     * Get a new binary object
     * @param string $data
     * @param string $mimetype
     *
     * @return Binary
     */
    public static function newBinary($data = null, $mimetype = null)
    {
        return new \core\Type\Binary($data, $mimetype);
    }

    /**
     * Get a new base 64 binary object
     * @param string $data
     * @param string $mimetype
     *
     * @return Base64Binary
     */
    public static function newBase64Binary($data = null, $mimetype = null)
    {
        return new \core\Type\Base64Binary($data, $mimetype);
    }

    /**
     * Get a new token list object
     * @param mixed  $values
     * @param string $separator
     *
     * @return TokenList
     */
    public static function newTokenList($values = null, $separator = null)
    {
        return new \core\Type\TokenList($values, $separator);
    }

    /**
     * Get a new json object
     * @param mixed   $value
     * @param integer $options
     *
     * @return Json
     */
    public static function newJson($value = null, $options = null)
    {
        return new \core\Type\Json($value, $options);
    }

    /**
     * Get a new xstring object
     * @param string $value
     * @param array  $attributes
     *
     * @return Json
     */
    public static function newXString($value = null, $attributes = null)
    {
        return new \core\Type\XString($value, $attributes);
    }

    /**
     * Get a new PackageFile object
     *
     * @param string $data
     * @param string  $name
     *
     * @return PackageFile
     */
    public static function newFileFromString($data, $name, $size = null, $encoding = null, $type = null)
    {
        return new \core\Type\StringFile($data, $name, $size, $encoding, $type);
    }

    /**
     * Get a new PackageFile object
     *
     * @param resource $data
     * @param string   $name
     *
     * @return PackageFile
     */
    public static function newFileFromStream($data, $name, $size = null, $encoding = null, $type = null)
    {
        return new \core\Type\StreamFile($data, $name, $size, $encoding, $type);
    }

    /**
     * Get a new PackageFile object
     *
     * @param string $data
     * @param string  $name
     *
     * @return PackageFile
     */
    public static function newFileFromUri($data, $name, $size = null, $encoding = null, $type = null)
    {
        return new \core\Type\UriFile($data, $name, $size, $encoding, $type);
    }

    /**
     * Check if a type is built-in
     * @param string $typename
     *
     * @return boolean
     */
    public static function isBuiltInType($typename)
    {
        return in_array($typename, self::$phpTypes);
    }

    /**
     * Get the patter to validate a string representation of a typed value
     * @param string $name
     *
     * @return string the pattern
     */
    public static function getTypePattern($name)
    {
        if (isset(self::$typePatterns[$name])) {
            return self::$typePatterns[$name];
        }

        return false;
    }

    /**
     * Get a laabs model type from Model layer
     * @param mixed $classname the fully qualified name of the type of an object of this type
     *
     * @return \code\Reflection\type
     */
    public static function getClass($classname)
    {
        switch (true) {
            case is_object($classname):
                $class = get_class($classname);
                $classParser = self::parseClass($class);
                if (!isset($classParser[LAABS_BUNDLE]) || !isset($classParser[LAABS_MODEL])) {
                    return null;
                }
                $bundleName = $classParser[LAABS_BUNDLE];
                $className = $classParser[LAABS_MODEL];

                break;

            case is_string($classname) && strpos($classname, LAABS_URI_SEPARATOR) > 0:
                // String is a laabs model type
                $bundleName = strtok($classname, LAABS_URI_SEPARATOR);
                $className = strtok(LAABS_URI_SEPARATOR);
                if (empty($bundleName) || empty($className)) {
                    return null;
                }

                break;

            case is_string($classname):
            default:
                return null;
        }

        $class = self::bundle($bundleName)->getClass($className);

        return $class;
    }

    /**
     * Get a laabs message type from Service layer
     * @param mixed $classname the fully qualified name of the type of an object of this type
     *
     * @return \code\Reflection\type
     */
    public static function getMessage($classname)
    {
        switch (true) {
            case is_object($classname):
                $classname = get_class($classname);
                $classParser = self::parseClass($classname);
                if (!isset($classParser[LAABS_BUNDLE]) || !isset($classParser[LAABS_MESSAGE])) {
                    return null;
                }
                $bundleName = $classParser[LAABS_BUNDLE];
                $className = $classParser[LAABS_MESSAGE];

                break;

            case is_string($classname) && strpos($classname, LAABS_URI_SEPARATOR) > 0:
                // String is a laabs model type
                $bundleName = strtok($classname, LAABS_URI_SEPARATOR);
                $className = strtok(LAABS_URI_SEPARATOR);
                if (empty($bundleName) || empty($className)) {
                    return null;
                }

                break;

            case is_string($classname):
            default:
                return null;
        }

        $message = self::bundle($bundleName)->getMessage($className);

        return $message;
    }

    /**
     * Instanciate a new object with given type name
     * @param string $classUri The class name bundle/class
     *
     * @return object
     */
    public static function newInstance($classUri)
    {
        $bundleName = strtok($classUri, LAABS_URI_SEPARATOR);
        $className = strtok(LAABS_URI_SEPARATOR);

        $type = self::bundle($bundleName)->getClass($className);

        $constructorArgs = func_get_args();
        array_shift($constructorArgs);

        return $type->newInstanceArgs($constructorArgs);
    }

    /**
     * Instanciate a new object with given type name
     * @param string $className       The class name bundle/class
     * @param array  $constructorArgs The arguments to pass to constructor of object
     *
     * @return object
     */
    public static function newInstanceArgs($className, array $constructorArgs = array())
    {
        $bundleName = strtok($className, LAABS_URI_SEPARATOR);
        $className = strtok(LAABS_URI_SEPARATOR);

        $type = self::bundle($bundleName)->getClass($className);

        return $type->newInstanceArgs($constructorArgs);
    }

    /**
     * Instanciate a new message with given type name
     * @param string $className       The class name bundle/message
     * @param array  $constructorArgs The arguments to pass to constructor of object
     *
     * @return object
     */
    public static function newMessage($className, array $constructorArgs = array())
    {
        $bundleName = strtok($className, LAABS_URI_SEPARATOR);
        $className = strtok(LAABS_URI_SEPARATOR);

        $messageType = self::bundle($bundleName)->getMessage($className);

        return $messageType->newInstance($constructorArgs);
    }

    /**
     * Cast a value into type, accepting array of objects
     * @param mixed  $sourceValue The source value, may be a scalar, object or array
     * @param string $typeName    The type of value (php type or class name or class[] array)
     * @param bool   $messageType Use message types instead of model types
     *
     * @return mixed The cast value
     */
    public static function cast($sourceValue, $typeName, $messageType = false)
    {
        // Cast php types
        switch (strtolower($typeName)) {
            // PHP types
            case 'integer':
            case 'int':
                return (integer) $sourceValue;

            case 'boolean':
            case 'bool':
                return filter_var($sourceValue, FILTER_VALIDATE_BOOLEAN);

            case 'float':
            case 'double':
            case 'real':
                return (float) $sourceValue;

            case 'string':
                return (string) $sourceValue;

            case 'resource':
                switch (true) {
                    case is_resource($sourceValue):
                        return $sourceValue;

                    case is_string($sourceValue) && filter_var(substr($sourceValue, 0, 128), FILTER_VALIDATE_URL):
                        return fopen($sourceValue, 'r');

                    case is_scalar($sourceValue):
                        return self::createTempStream((string) $sourceValue);
                    
                    default:
                        return self::createTempStream('');
                }
                break;

            case 'NULL':
                return $sourceValue;

            case 'array':
                return (array) $sourceValue;

            case 'object':
                if (is_object($sourceValue)) {
                    return $sourceValue;
                } else {
                    return null;
                }
        }

        if (is_null($sourceValue) || empty($sourceValue)) {
            return null;
        }

        // Cast laabs simple types if not null
        switch ($typeName) {
            // Laabs derived types
            case 'name':
                return self::newName((string) $sourceValue);

            case 'qname':
                return self::newQName((string) $sourceValue);

            case 'id':
                return self::newId((string) $sourceValue);

            case 'date':
                return self::newDate((string) $sourceValue);

            case 'datetime':
                return self::newDateTime((string) $sourceValue);

            case 'timestamp':
                return self::newTimestamp((string) $sourceValue);

            case 'duration':
                return self::newDuration((string) $sourceValue);

            case 'number':
                return self::newNumber($sourceValue);

            case 'xml':
                return self::newXml((string) $sourceValue);

            case 'tokenlist':
                if (!$sourceValue instanceof \Core\Type\TokenList) {
                    return self::newTokenList($sourceValue);
                }
                break;

            case 'binary':
                if (preg_match('#^data:(?<mimetype>\w+\/\w+);(\w+\s*:\w+;)*base64\,(?<data>.*)#', (string) $sourceValue, $matches)) {
                    return self::newBinary(base64_decode($matches['data'], $matches['mimetype']));
                }

                return self::newBinary((string) $sourceValue);

            case 'base64binary':
                if (preg_match('#^data:(?<mimetype>\w+\/\w+);(\w+\s*:\w+;)*base64\,(?<data>.*)#', (string) $sourceValue, $matches)) {
                    return self::newBase64Binary($matches['data'], $matches['mimetype']);
                }

                return self::newBase64Binary(base64_encode((string) $sourceValue));

            case 'json':
                if (is_string($sourceValue) && self::isJson($sourceValue)) {
                    $jsonValue = json_decode($sourceValue);

                    return self::newJson($jsonValue);
                }

                return self::newJson($sourceValue);

            case 'xstring':
                if (is_string($sourceValue) && self::isJson($sourceValue)) {
                    $jsonValue = json_decode($sourceValue);

                    switch (true) {
                        case (is_object($jsonValue) && isset($jsonValue->value)):
                            if (isset($jsonValue->attributes)) {
                                foreach ($jsonValue->attributes as $name => $value) {
                                    $xStringAttrs[$name] = $value;
                                }
                            } else {
                                $xStringAttrs = array();
                            }

                            return self::newXString($jsonValue->value, $xStringAttrs);

                        case is_string($jsonValue):
                            return self::newXString($jsonValue);

                        case is_array($jsonValue):
                            return null;
                    }
                } elseif ($sourceValue instanceof \DOMElement) {
                    $attributes = array();
                    foreach ($sourceValue->attributes as $name => $attrNode) {
                        $attributes[$attrNode->name] = $attrNode->value;
                    }

                    return self::newXString($sourceValue->nodeValue, $attributes);
                } elseif (is_object($sourceValue)) {
                    if (is_object($sourceValue->attributes)) {
                        $attributes = get_object_vars($sourceValue->attributes);
                    } else {
                        $attributes = $sourceValue->attributes;
                    }

                    return self::newXString($sourceValue->value, $attributes);
                }

                return self::newXString($sourceValue);
            case 'file':
                switch ($sourceValue['packageType']) {
                    case 'string':
                        return self::newFileFromString(
                            $sourceValue['data'],
                            $sourceValue['name'],
                            $sourceValue['size'],
                            $sourceValue['type'],
                            $sourceValue['encoding']
                        );
                    case 'stream':
                        return self::newFileFromStream(
                            $sourceValue['data'],
                            $sourceValue['name'],
                            $sourceValue['size'],
                            $sourceValue['type'],
                            $sourceValue['encoding']
                        );
                    case 'uri':
                        return self::newFileFromUri(
                            $sourceValue['data'],
                            $sourceValue['name'],
                            $sourceValue['size'],
                            $sourceValue['type'],
                            $sourceValue['encoding']
                        );
                    // no break
                }
                // no break
            default:
                // Cast to a typed array
                if (substr($typeName, -2) == "[]") {
                    $rowTypeName = substr($typeName, 0, -2);
                    if (strpos($rowTypeName, LAABS_URI_SEPARATOR) !== false) {
                        return self::castCollection($sourceValue, $rowTypeName, $messageType);
                    } else {
                        foreach ($sourceValue as $key => $sourceRow) {
                            $targetValue[$key] = self::cast($sourceRow, $rowTypeName, $messageType);
                        }

                        return $targetValue;
                    }
                }

                if (strpos($typeName, LAABS_URI_SEPARATOR) !== false) {
                    switch (true) {
                        // Object
                        case is_object($sourceValue):
                            return self::castObject($sourceValue, $typeName, $messageType);
                        // String (json, XML...) : use constrictor
                        default:
                            if ($messageType) {
                                return self::newMessage($typeName, array($sourceValue));
                            } else {
                                return self::newInstance($typeName);
                            }
                    }
                }
        }

        // Unknown type
        return $sourceValue;

    }

    /**
     * Model Class casting
     * @param object $sourceObject The source object
     * @param mixed  $className    The name of the model class (bundle/name)
     * @param bool   $messageType  Use message types instead of model types
     *
     * @return object
     */
    public static function castObject($sourceObject, $className, $messageType = false)
    {
        if ($messageType) {
            $targetClass = self::getMessage($className);
        } else {
            $targetClass = self::getClass($className);
        }

        if (!$targetClass) {
            throw new \core\Exception("Type $className is not defined");
        }

        $targetObject = $targetClass->newInstanceWithoutConstructor();

        $targetProperties = $targetClass->getProperties();
        foreach ($targetProperties as $targetProperty) {
            if (!$targetProperty->isPublic()) {
                $targetProperty->setAccessible(true);
            }

            $name = $targetProperty->getBaseName();

            if (!isset($sourceObject->{$name})) {
                continue;
            }

            $sourceValue = $sourceObject->{$name};
            $targetType = $targetProperty->getType();

            if (!isset($targetType)) {
                $targetValue = $sourceValue;
            } else {
                try {
                    $targetValue = self::cast($sourceValue, $targetType, $messageType);
                } catch (\core\Exception $e) {
                    $context = array(
                        'class' => $className,
                        'property' => $name,
                        'parameter' => $name,
                        'type' => $targetType,
                        'value' => $sourceValue,
                    );
                    $vars = $e->getVariables();
                    $vars = array_merge($vars, $context);
                    $e->setVariables($vars);
                    
                    throw $e;
                }
            }

            $targetProperty->setValue($targetObject, $targetValue);
        }

        return $targetObject;
    }

    /**
     * Cast a value into message type, accepting array of objects
     * @param mixed  $sourceValue The source value, may be a scalar, object or array
     * @param string $typeName    The type of value (php type or class name or class[] array)
     *
     * @return mixed The cast value
     */
    public static function castMessage($sourceValue, $typeName)
    {
        return self::cast($sourceValue, $typeName, true);
    }

    /**
     * Message type casting
     * @param object $sourceObject The source object
     * @param mixed  $className    The name of the message type (bundle/name)
     *
     * @return object
     */
    public static function castMessageObject($sourceObject, $className)
    {
        return self::castObject($sourceObject, $className, true);
    }

    /**
     * Message type casting
     * @param array  $sourceCollection The collection of objects
     * @param string $className        The name of the model component to cast into
     *
     * @return object
     */
    public static function castMessageCollection($sourceCollection, $className)
    {
        return self::castCollection($sourceCollection, $className, true);
    }

    /**
     * Cast a collection of objects
     * @param array  $sourceCollection The collection of objects
     * @param string $className        The name of the model component to cast into
     * @param bool   $messageType      Use message types instead of model types
     *
     * @return array
     */
    public static function castCollection(array $sourceCollection, $className, $messageType = false)
    {
        if ($messageType) {
            $targetClass = self::getMessage($className);
        } else {
            $targetClass = self::getClass($className);
        }

        $targetProperties = $targetClass->getProperties();
        foreach ($targetProperties as $targetProperty) {
            if (!$targetProperty->isPublic()) {
                $targetProperty->setAccessible(true);
            }
        }

        $targetCollection = array();
        foreach ($sourceCollection as $sourceObject) {
            $targetObject = $targetClass->newInstanceWithoutConstructor();

            foreach ($targetProperties as $targetProperty) {
                $name = $targetProperty->getBaseName();

                if (!isset($sourceObject->{$name})) {
                    continue;
                }

                $sourceValue = $sourceObject->{$name};
                $targetType = $targetProperty->getType();

                if (!isset($targetType)) {
                    $targetValue = $sourceValue;
                } else {
                    $targetValue = self::cast($sourceValue, $targetType, $messageType);
                }

                $targetProperty->setValue($targetObject, $targetValue);
            }

            $targetCollection[] = $targetObject;
        }

        return $targetCollection;
    }

    /**
     * Checks if a value is scalar
     * @param mixed $value The value
     *
     * @return bool
     */
    public static function isScalar($value)
    {
        // Get type with classname if object
        // * php type (string, integer, boolean, float, resource...)
        // * object of model (bundle\Model\class)
        // * Laabs built-in type (core\Type\laabsType)
        $typename = \laabs\gettype($value);

        switch (true) {
            // Type name contains namespace separator
            case strpos($typename, LAABS_NS_SEPARATOR) !== false:
                // Type namespace is laabs core, this is a built-in type, ask Laabs if it is scalar
                // Other namespaces are complex types from business model or whatever
                if (strtok($typename, LAABS_NS_SEPARATOR) == LAABS_CORE) {
                    return self::isScalarType(\laabs\basename($typename));
                } else {
                    return false;
                }

            // Built-in php type
            default:
                return self::isScalarType($typename);

        }
    }

    /**
     * Checks if a type name is scalar
     * @param string $type The name of the type
     *
     * @return bool
     */
    public static function isScalarType($type)
    {
        return in_array(strtolower($type), self::$scalarTypes);
    }

    /**
     * Checks if a value is serializable into json
     * @param mixed $value The value
     *
     * @return bool
     */
    public static function isJsonSerializable($value)
    {
        if (self::isScalar($value)) {
            return true;
        }


    }

    /**
     * Get a laabs model class name from php class
     * @param string $class The class of object or object itself
     *
     * @return string
     */
    public static function getClassName($class)
    {
        if (is_object($class)) {
            $class = \get_class($class);
        }

        $classParser = self::parseClass($class);
        if (!isset($classParser[LAABS_BUNDLE]) || !isset($classParser[LAABS_MODEL])) {
            return null;
        }

        return $classParser[LAABS_BUNDLE].LAABS_URI_SEPARATOR.$classParser[LAABS_MODEL];
    }

    /**
     * Get the base php type from a given simple / derived / user type
     * @param string $typename
     *
     * @return string The php base type
     */
    public static function getPhpType($typename)
    {
        if (in_array($typename, self::$phpTypes)) {
            return $typename;
        }

        if (array_key_exists($typename, self::$derivedTypes)) {
            return self::$derivedTypes[$typename];
        }

        // Search base of user types
    }

    /**
     * Get the derived laabs type from a given user type
     * @param string $typename
     *
     * @return string The php base type
     */
    public static function getDerivedType($typename)
    {
        if (array_key_exists($typename, self::$derivedTypes)) {
            return $typename;
        }

        // Search base of user types
    }


    /**
     * Validate an object versus the schema. Partial objects are not allowed
     * @param object  $object      The object to validate
     * @param string  $typeName    The class name to validate object against
     * @param boolean $messageType Validate from message instead of model
     *
     * @return bool
     */
    public static function validate($object, $typeName = false, $messageType = false)
    {
        self::$validationErrors = array();
        self::$validationStatus = true;

        if ($typeName) {
            if ($messageType) {
                $type = self::getMessage($typeName);
            } else {
                $type = self::getClass($typeName);
            }
        } else {
            if (is_object($object)) {
                if ($messageType) {
                    $type = self::getMessage($object);
                } else {
                    $type = self::getClass($object);
                }
            }
            if (!$type) {
                throw new \Exception("Can't validate object: You must provide either an object of required type or a type name.");
            }
        }

        self::validateObject($object, $type, $messageType);

        //var_dump(self::$validationErrors);

        return self::$validationStatus;
    }

    /**
     * Validate an object versus the message schema. Partial objects are not allowed
     * @param array  $message     The message (associative array)
     * @param object $servicePath The reflection service path
     *
     * @return bool
     */
    public static function validateMessage($message, $servicePath)
    {
        self::$validationErrors = array();
        self::$validationStatus = true;

        $messageName = $servicePath->getName();
        $parameters = $servicePath->getParameters();

        foreach ($parameters as $parameter) {
            $parameterName = $parameter->getName();
            $context = array(
                'message' => $messageName,
                'parameter' => $parameterName,
            );

            // If null, validate nullable and return
            if (!isset($message[$parameterName])) {
                if (!$parameter->isDefaultValueAvailable()) {
                    self::triggerValidationError('Null value not allowed', $context);
                }

                continue;
            }

            $parameterValue = $message[$parameterName];

            $valid = self::validateParameter($parameterValue, $parameter, $messageName);
        }

        return self::$validationStatus;
    }

    protected static function validateParameter($parameterValue, $parameter, $messageName)
    {
        $parameterType = $parameter->getType();

        $context = array(
            'message' => $messageName,
            'parameter' => $parameter->getName(),
            'type' => $parameterType,
        );

        if (in_array($parameterType, self::$phpTypes)) {
            if (!self::validatePhpType($parameterType, $parameterValue)) {
                self::triggerValidationError('Invalid base data type', $context);

                return;
            }
        }
        // Continue to derived types

        // Validate derived type
        if (array_key_exists($parameterType, self::$derivedTypes)) {
            if (!self::validateDerivedType($parameterType, $parameterValue)) {
                self::triggerValidationError('Invalid derived data type', $context);
            }

            return;
        }

        // Validate array type
        if ($parameterType == "array" || substr($parameterType, -2) == "[]") {
            if (!is_array($parameterValue)) {
                self::triggerValidationError('Invalid array data type', $context);

                return;
            }

            $messageTypeName = substr($parameterType, 0, -2);
            if (strpos($messageTypeName, LAABS_URI_SEPARATOR)) {
                $messageType = self::getMessage($messageTypeName);
                foreach ($parameterValue as $itemObject) {
                    self::validateObject($itemObject, $messageType, $messageType = true);
                }
            }

            return;
        }

        // Validate object
        if (strpos($parameterType, LAABS_URI_SEPARATOR)) {
            $messageType = self::getMessage($parameterType);
            self::validateObject($parameterValue, $messageType, true);
        }

        return self::$validationStatus;
    }

    /**
     * Validate some data against schema. Partial objects are allowed, only set properties will be checked
     * @param object  $object      The object to validate
     * @param string  $typeName    The type name to validate object against
     * @param boolean $messageType Validate from message instead of model
     *
     * @return bool
     */
    public static function validateData($object, $typeName, $messageType = false)
    {
        self::$validationErrors = array();
        self::$validationStatus = true;

        if ($messageType) {
            $type = self::getMessage($typeName);
        } else {
            $type = self::getClass($typeName);
        }

        foreach (get_object_vars($object) as $propertyName => $propertyValue) {
            $property = $type->getProperty($propertyName);
            self::validateProperty($propertyValue, $property, $typeName, $messageType);
        }

        return self::$validationStatus;
    }

    /**
     * Validate object
     * @param object                $object      The object to validate
     * @param \core\Reflection\Type $class       The type/class definition
     * @param boolean               $messageType Validate from message instead of model
     *
     * @return bool
     */
    protected static function validateObject($object, $class, $messageType = false)
    {
        $properties = $class->getProperties();
        foreach ($properties as $property) {
            $context = array(
                'class' => $class->getName(),
                'property' => $property->getName(),
            );

            $property->setAccessible(true);
            $propertyValue = $property->getValue($object);

            // If null, validate nullable and return
            if (is_null($propertyValue)) {
                if (!$property->isNullable()) {
                    self::triggerValidationError('Null value not allowed', $context);
                }

                continue;
            }

            // If empty, validate emptyable, return if empty
            if (empty($propertyValue) && !$property->isEmptyable()) {
                self::triggerValidationError('Empty value not allowed', $context);

                continue;
            }

            self::validateProperty($propertyValue, $property, $class->getName(), $messageType);
        }
    }

    /**
     * Validate a property vs schema
     * @param object  $propertyValue The value to validate
     * @param object  $property      The property definition
     * @param string  $className     The class of property
     * @param boolean $messageType   Validate from message instead of model
     *
     * @return bool
     */
    protected static function validateProperty($propertyValue, $property, $className, $messageType = false)
    {
        $propertyType = $property->getType();

        $context = array (
            'class' => $className,
            'property' => $property->getName(),
            'type' => $propertyType,
        );

        // Validate base type
        if (in_array($propertyType, self::$phpTypes)) {
            if (!self::validatePhpType($propertyType, $propertyValue)) {
                self::triggerValidationError('Invalid base data type', $context);

                return;
            }
        }

        // Validate derived type
        if (array_key_exists($propertyType, self::$derivedTypes)) {
            if (!self::validateDerivedType($propertyType, $propertyValue)) {
                self::triggerValidationError('Invalid derived data type', array_merge($context, array('data' => $propertyValue)));

                return;
            }
        }

        // Validate array type
        if (substr($propertyType, -2) == "[]") {
            if (!is_array($propertyValue)) {
                self::triggerValidationError('Invalid data type', $context);
            }

            $propertyMaxLength = $property->getMaxLength();
            if ($propertyMaxLength && count($propertyValue) > $propertyMaxLength) {
                self::triggerValidationError('Number of items exceeds maximum length', array_merge($context, array('maxLength' => $propertyMaxLength)));
            }

            $propertyMinLength = $property->getMinLength();
            if ($propertyMinLength && count($propertyValue) < $propertyMinLength) {
                self::triggerValidationError('Number of items is under minimum length', array_merge($context, array('minLength' => $propertyMinLength)));
            }

            $propertyLength = $property->getLength();
            if ($propertyLength && count($propertyValue) != $propertyLength) {
                self::triggerValidationError('Invalid number of items', array_merge($context, array('length' => $propertyLength)));
            }

            $typeName = substr($propertyType, 0, -2);
            if (strpos($typeName, LAABS_URI_SEPARATOR)) {
                if ($messageType) {
                    $type = self::getMessage($typeName);
                } else {
                    $type = self::getClass($typeName);
                }
                foreach ($propertyValue as $itemObject) {
                    self::validateObject($itemObject, $type, $messageType);
                }
            }

            return;
        }

        // Validate object
        if (strpos($propertyType, LAABS_URI_SEPARATOR)) {
            if ($messageType) {
                $type = self::getMessage($propertyType);
            } else {
                $type = self::getClass($propertyType);
            }

            self::validateObject($propertyValue, $type, $messageType);

            return;
        }

        // Validate simple type value facets
        self::validateTypeFacets($propertyValue, $property, $className);

        return self::$validationStatus;
    }

    protected static function validatePhpType($phpType, $propertyValue)
    {
        //var_dump("validatePhpType $phpType");
        switch ($phpType) {
            case 'string':
                if (!is_string($propertyValue)) {
                    return false;
                }
                break;

            case 'integer':
                if (!ctype_digit((string) $propertyValue) || !is_numeric($propertyValue)) {
                    return false;
                }
                break;

            case 'float':
                if (!is_numeric($propertyValue)) {
                    return false;
                }
                break;

            case 'boolean':
                if (!is_bool($propertyValue)) {
                    return false;
                }
                break;

            case 'resource':
                if (!is_resource($propertyValue)) {
                    return false;
                }
                break;
        }

        return true;
    }

    protected static function validateDerivedType($derivedType, $propertyValue)
    {
        //var_dump("validateDerivedType($derivedType, $propertyValue)");
        switch (strtolower($derivedType)) {
            case 'date':
                if (!($propertyValue instanceof \core\Type\Date)) {
                    return false;
                }
                break;

            case 'timestamp':
                if (!($propertyValue instanceof \core\Type\Timestamp)) {
                    return false;
                }
                break;

            case 'duration':
                if (!($propertyValue instanceof \core\Type\Duration)) {
                    return false;
                }
                break;

            case 'id':
                if (!($propertyValue instanceof \core\Type\Id)) {
                    return false;
                }
                break;

            case 'name':
                if (!($propertyValue instanceof \core\Type\Name)) {
                    return false;
                }
                break;

            case 'number':
                if (!($propertyValue instanceof \core\Type\Number)) {
                    return false;
                }
                break;

            case 'qname':
                if (!preg_match('#^[A-Za-z_][A-Za-z0-9_]*(\/[A-Za-z_][A-Za-z0-9_]*)*$#', $propertyValue)) {
                    return false;
                }
                break;

            case 'xml':
                if (!($propertyValue instanceof \core\Type\Xml)) {
                    return false;
                }
                break;

            case 'tokenlist':
                if (!($propertyValue instanceof \core\Type\TokenList)) {
                    return false;
                }
                break;

            case 'binary':
                if (!($propertyValue instanceof \core\Type\Binary)) {
                    return false;
                }
                break;

            case 'json':
                if (!($propertyValue instanceof \core\Type\Json)) {
                    return false;
                }
                break;
        }

        return true;
    }

    protected static function validateTypeFacets($propertyValue, $property, $className)
    {
        $propertyName = $property->getName();
        $propertyType = $property->getType();
        $context = array (
            'class' => $className,
            'property' => $property->getName(),
            'type' => $propertyType,
        );

        // Validate simple type facets
        $enumeration = $property->getEnumeration();
        if ($enumeration && !in_array($propertyValue, $enumeration)) {
            self::triggerValidationError('String value is not in enumerated values', array_merge($context, array('enumeration' => implode(', ', $enumeration))));
        }

        $maxLength = $property->getMaxLength();
        if ($maxLength && strlen((string) $propertyValue) > $maxLength) {
            self::triggerValidationError('String value exceeds maximum length', array_merge($context, array('maxLength' => $maxLength)));
        }

        $minLength = $property->getMinLength();
        if ($minLength && strlen((string) $propertyValue) < $minLength) {
            self::triggerValidationError('String value is under minimum length', array_merge($context, array('minLength' => $minLength)));
        }

        $length = $property->getLength();
        if ($length && strlen((string) $propertyValue) != $length) {
            self::triggerValidationError('String value does not match required length', array_merge($context, array('length' => $length)));
        }

        $pattern = $property->getPattern();
        if ($pattern && !preg_match($pattern, $propertyValue)) {
            self::triggerValidationError('String value does not match pattern', array_merge($context, array('pattern' => $pattern)));
        }

        // Check numeric value
        $maxValue = (int) $property->getMaxValue();
        if ($maxValue && $propertyValue > $maxValue) {
            self::triggerValidationError('Numeric value exceeds maximum value', array_merge($context, array('maxValue' => $maxValue)));
        }

        $minValue = (int) $property->getMinValue();
        if ($minValue && $propertyValue < $minValue) {
            self::triggerValidationError('Numeric value exceeds is under minimal value', array_merge($context, array('minValue' => $minValue)));
        }
    }

    /**
     * Alphabetical sort method to use like a callable function
     *
     * @param mixte   $a       The first value
     * @param mixte   $b       The second value
     * @param string  $param   The optional param name to compare if values are objects
     * @param boolean $inverse The boolean to define the order
     *
     * @return int The order
     */
    public static function alphabeticalSort($a, $b, $param = null, $inverse = false)
    {
        $inverseOperator = $inverse ? -1 : 1;

        if ($param) {
            $a = \laabs::normalize(trim($a->$param));
            $b = \laabs::normalize(trim($b->$param));
        } else {
            $a = \laabs::normalize(trim($a));
            $b = \laabs::normalize(trim($b));
        }

        if ($a == $b) {
            return 0;
        }

        return $inverseOperator * (($a < $b) ? -1 : 1);
    }

    /**
     * Return the validation errors
     *
     * @return array
     */
    public static function getValidationErrors()
    {
        return self::$validationErrors;
    }

    //protected function validateReferences($class, $object);

    /**
     * Add a validation error to the stack of errors
     * @param string $message   The message of error (or a format of message)
     * @param array  $variables An array of variable values to merge the message format
     * @param string $code      The code of the error
     *
     * @return void
     */
    protected static function triggerValidationError($message, $variables = null, $code = 0)
    {
        self::$validationStatus = false;
        self::$validationErrors[] = new \core\Error($message, $variables, $code);
    }

    /**
     * Get the key string for a given object with type
     * Passing an object as first argument will return the associated object id.
     * Passing a type name as first argument will generate and return a new unique identifier.
     * @param mixed  $object   The object to get key of or to
     * @param string $typename Optional: The type of object if first argument is an object. If not given, it will be determined from object
     *
     * @return string The id value (key field values with uri separator)
     */
    public static function objectId($object, $typename = false)
    {
        $keyValue = [];

        if (is_object($object)) {
            if (!$typename) {
                $type = self::getClass($object);
            } else {
                $type = self::getClass($typename);
            }
            $key = $type->getPrimaryKey();

            if (!$key) {
                throw new \newException("Unable to get key string for object : No key defined");
            }

            foreach ($key->getFields() as $keyField) {
                $fieldValue = $object->{$keyField};
                $property = $type->getProperty($keyField);

                if (!self::isScalarType($property->getType())) {
                    throw new \core\Exception("Unable to get key string for object :Key field '$keyField' value is not a valid scalar value");
                }
                $keyValue[] = $fieldValue;
            }
        } elseif (is_string($object)) {
            $type = self::getClass($object);

            $key = $type->getPrimaryKey();

            if (!$key) {
                throw new \newException("Unable to get key string for object : No key defined");
            }

            $keyFields = $key->getFields();

            // Base value is a unique id with timestamp + rand
            $keyField = reset($keyFields);
            $keyValue[] = \laabs\uniqid();

            // Next values
            while ($keyField = next($keyFields)) {
                $keyValue[] = \laabs\uniqid();
            }
        }

        return implode(LAABS_URI_SEPARATOR, $keyValue);
    }

    /**
     * Query an array of objects to filter
     * @param array  $collection  The collection of objects to filter
     * @param string $class       The class of collection objects
     * @param string $queryString The LQL query
     *
     * @return array
     */
    public static function filter($collection, $class, $queryString)
    {
        $return = array();

        $parser = new \core\Language\Parser();
        $query = new \core\Language\Query();
        $query->setClass(\laabs::getClass($class));

        $assert = $parser->parseAssert($queryString, $query);
        $compiler = new \core\Language\Compiler();
        $phpAssert = $compiler->getAssertExpression($assert);

        //var_dump($phpAssert);

        assert_options(ASSERT_ACTIVE, 1);
        assert_options(ASSERT_WARNING, 0);
        assert_options(ASSERT_QUIET_EVAL, 1);

        $localName = \laabs\basename($class);

        foreach ($collection as ${$localName}) {
            if (assert($phpAssert)) {
                $return[] = ${$localName};
            }
        }

        return $return;
    }

    /**
     * Assert on an object
     * @param object $object      The object
     * @param string $queryString The LQL query
     * @param string $classname   The class of object
     *
     * @return array
     */
    public static function assert($object, $queryString, $classname = null)
    {
        if ($classname) {
            $class = \laabs::getClass($classname);
        } else {
            $class = \laabs::getClass($object);
        }

        $parser = new \core\Language\Parser();
        $query = new \core\Language\Query();
        $query->setClass($class);

        $assert = $parser->parseAssert($queryString, $query);
        $compiler = new \core\Language\Compiler();
        $phpAssert = $compiler->getAssertExpression($assert);

        assert_options(ASSERT_ACTIVE, 1);
        assert_options(ASSERT_WARNING, 0);
        assert_options(ASSERT_QUIET_EVAL, 1);

        $localName = \laabs\basename($class->getName());
        ${$localName} = $object;

        return assert($phpAssert);
    }

    /**
     * Build a tree structure from a flat array
     * @param array  &$objects
     * @param string $className
     * @param string $childListProperty
     * @param string $rootId
     *
     * @return array|object
     */
    public static function buildTree(array &$objects, $className, $childListProperty=null, $rootId=false)
    {
        $class = \laabs::getClass($className);
        
        $selfKeys = $class->getForeignKeys($className);
        if (count($selfKeys) == 0) {
            return array();
        }
        $selfKey = reset($selfKeys);
        $keyField = $selfKey->getFields()[0];
        $refField = $selfKey->getRefFields()[0];

        if (!$childListProperty) {
            $childListProperty = $class->getShortName();
            foreach ($class->getProperties() as $property) {
                if ($property->getType() == $className.'[]') {
                    $childListProperty = $property->getName();
                }
            }
        }

        if ($rootId) {
            foreach ($objects as $object) {
                if ($object->{$refField} == $rootId) {
                    if ($children = static::buildBranch($objects, $object->{$refField}, $refField, $keyField, $childListProperty)) {
                        $object->{$childListProperty} = $children;
                    }

                    return $object;
                }
            }
        } else {
            return static::buildBranch($objects, null, $refField, $keyField, $childListProperty);
        }
        
    }

    protected static function buildBranch(array &$objects, $parentId, $idProperty, $parentIdProperty, $childListProperty)
    {
        $branch = array();

        foreach ($objects as $object) {
            if ($object->{$parentIdProperty} == $parentId) {
                if ($children = static::buildBranch($objects, $object->{$idProperty}, $idProperty, $parentIdProperty, $childListProperty)) {
                    $object->{$childListProperty} = $children;
                }
                $branch[] = $object;
                unset($object);
            }
        }

        return $branch;
    }

    /**
     * Adds the canonical path of objects in tree
     * @param array  $objects    The tree roots or branches
     * @param string $name       The property that contains the name
     * @param string $path       The property to evaluate with the path
     * @param string $parentPath The parent folder path
     */
    public static function C14NPath($objects, $name, $path, $parentPath=null) 
    {
        foreach ($objects as $object) {
            if ($parentPath) {
                $object->{$path} = $parentPath.'/'.$object->{$name};
            } else {
                $object->{$path} = $object->{$name};
            }
            if (is_array($object->subFolders)) {
                static::C14NPath($object->subFolders, $name, $path, $object->{$path});
            }
        }
    }
}
